---
title: "SVGs, Icon Loaders, and Modular Design Systems in Modern Sitecore Builds"
date: 2025-10-16
summary: "A deep dive into using SVGs and automated icon loaders to create scalable, themeable, and maintainable design systems within composable Sitecore XM Cloud front-ends."
tags: ["sitecore", "atomic design", "svg", "icons", "webpack", "webfonts-loader", "design system", "vercel", "xmc"]
draft: true
---

## Introduction

In every modern composable Sitecore XM Cloud build, one recurring challenge is **how to manage icons** — ensuring they remain consistent, themeable, and easy to extend without disrupting downstream components or breaking existing styling.  
Traditional approaches (like manually exporting fonts from IcoMoon) quickly become brittle and repetitive as projects scale.

This article explores a **modern architectural pattern** that treats SVG files as the _source of truth_ while introducing an automated _icon loader pipeline_ to make icons consistent, reusable, and theme-aware.  
It’s a foundational technique for teams building **Atomic Design systems** in headless Sitecore environments.

---

## 1. Architecture Overview

### SVGs as Design Atoms

SVG files are vector-based, resolution-independent, and ideal for representing icons.  
In a scalable design system, we treat these SVGs as the **atomic level of visual components** — the smallest, indivisible assets that inform all larger UI compositions.

Design teams hand these over (usually exported from Figma) to developers as a **pure source set**:

src/assets/icons/
├── alert.svg
├── calendar.svg
└── search.svg


These raw files remain **the single source of truth**, versioned in Git.

---

### From Source → System: Why Use an Icon Loader

While individual SVGs can be used directly, they come with drawbacks:
- inconsistent sizing (`viewBox`, padding)
- hard-coded fills that break theming
- no class-based control
- multiple network requests

An **icon loader** such as [`webfonts-loader`](https://github.com/jeerbl/webfonts-loader) solves these problems by automating the transformation:

/src/assets/icons/*.svg
↓ (build step)
fonts/
csr-icons.woff2
csr-icons.css


This process:
1. Normalizes every SVG.
2. Generates a single webfont file (or sprite).
3. Builds a CSS/SCSS mapping for each icon.
4. Applies a naming prefix (`csr-icon-*`) for scoped theming.

Developers now use:
```html
<i class="csr-icon-alert"></i>
instead of manually referencing SVG files.

2. Architectural Benefits
Goal	Traditional SVGs	With Icon Loader
Consistency	Different sizing/fills	Normalized at build
Performance	Multiple HTTP requests	One compiled font
Theming	Hard-coded color fills	Token-driven via CSS variables
Reusability	Each component imports SVGs individually	Centralized font + SCSS
Modularity	Ad-hoc naming	Scoped prefixes per brand/theme
Maintainability	Manual rebuilds	Automated during CI/CD
Alignment with Atomic Design

In Atomic Design terms:

Atoms → individual SVGs (source files)

Molecules → icon components (React wrappers, <Icon name="alert" />)

Organisms → larger assemblies that reference icons via tokens

Templates/Pages → rendered by Sitecore XM Cloud and themed via design tokens

Each layer references the previous through composition, not duplication — ensuring global consistency and faster change propagation.

Composability and Sitecore XM Cloud

In composable Sitecore architectures:

Icons are never stored in Sitecore; only their symbolic name (e.g., csr-icon-alert) is referenced in JSON or datasource fields.

The Vercel-hosted front-end imports the pre-compiled font and applies classes dynamically based on content data.

Theming is achieved via CSS variables and token overrides per tenant, enabling multi-brand and dark-mode variants without asset duplication.

3. Startup Guide — Setting It Up from Scratch

Below is a step-by-step guide for adding automated icon generation to any vanilla build (React/Next.js, Webpack-based).

Step 1. Install Dependencies
npm install --save-dev webfonts-loader webpack webpack-cli

Step 2. Create Your SVG Source Directory
src/assets/icons/
├── alert.svg
├── calendar.svg
└── search.svg
Keep file names lowercase and kebab-cased.
Each icon should have a clean viewBox (no inline fills if you want CSS theming).

Step 3. Define the Icon Font Config

Create src/assets/icons/icons.font.js:

module.exports = {
  files: ['./src/assets/icons/**/*.svg'],
  fontName: 'csr-icons',
  cssTemplate: 'scss',
  classPrefix: 'csr-icon-',
  fixedWidth: true,
  normalize: true,
  formats: ['woff2', 'woff'],
};

Step 4. Configure Webpack Loader

In your webpack.config.js (or equivalent):

const path = require('path');

module.exports = {
  module: {
    rules: [
      {
        test: /\.font\.js/,
        use: [
          'css-loader',
          'webfonts-loader'
        ]
      }
    ]
  },
  resolve: {
    alias: {
      '@icons': path.resolve(__dirname, 'src/assets/icons')
    }
  }
};

Step 5. Import the Generated Styles

Inside your main stylesheet or component entry:

@import './assets/icons/icons.css';

// Example usage
.icon {
  display: inline-block;
  color: var(--icon-color, currentColor);
  font-size: 1.25rem;
}

Step 6. Use Icons in Your Components

<i class="csr-icon-alert"></i>
<i class="csr-icon-calendar"></i>
All icons are now served via a single compiled font — no separate SVG imports required.

Step 7. (Optional) Integrate with a Theming System

For multi-brand or dark/light theming:

[data-theme='dark'] .csr-icon-alert { color: var(--icon-color-dark); }
[data-theme='light'] .csr-icon-alert { color: var(--icon-color-light); }

or token-driven:

.csr-icon-alert {
  color: var(--token-icon-alert);
}

4. Continuous Integration and Maintenance

Add the icon generation step to your CI/CD pipeline so any new SVGs dropped into src/assets/icons/ automatically regenerate the webfont on build.
No more IcoMoon exports or manual syncing.

Typical workflow:

Designer adds new icon → commits to Git.

Pipeline runs Webpack build → generates new fonts & CSS.

Icons immediately available in Storybook, Vercel preview, and Sitecore front-end.

5. Key Takeaways

SVGs remain your design source of truth.

Automation guarantees consistency and reduces human error.

Theming and modularity become first-class citizens.

Perfect alignment with Atomic Design principles.

Future-proof for composable architectures like Sitecore XM Cloud.

Conclusion

Adopting an icon-loader workflow transforms a front-end from asset-driven to system-driven.
By treating icons as composable tokens — generated from consistent SVG sources — teams gain maintainability, scalability, and true theming flexibility across brands and environments.

This small shift creates a massive architectural advantage, ensuring your design system can evolve as quickly as your digital experience platform does.

---